; Modular Master Control Program
; Copyright (C) by Marcin "Ktos" Badurowicz 2012
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.


; go to initialization
set pc, mcp_init

; THESE MEMORY VALUES ARE MODIFIED BY configure SCRIPTS
; list of modules
; or rather their initial subroutines' addresses
:modules
dat 0

; list of modules avaliable by menu
; or rather their menu subroutines' addresses
:modules_menu
dat 0

; list of modules avaliable by console
; or rather their console subroutines' addresses
:modules_console
dat 0

; module which will be run as the first one
:module_entry dat 0

; useful additional variables/memory addresses reserved
:entropy
dat 0

:buffer
dat 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

:video_cur
dat 0x0000

; ##############################################################################
; Common API
; ##############################################################################

; strcmp(char* a, char* b)
; return in a
; 1 = same
; 0 = different
:strcmp

:strcmp_loop
     set c, 0

     ife [a], [b]
          jsr strcmp_checkend

     ife c, 1
          set pc, strcmp_end

     ifn [a], [b]
         set pc, strcmp_end

     add a, 1
     add b, 1
     set pc, strcmp_loop

:strcmp_checkend
     ife [a], 0
          set c, 1
     set pc, pop

:strcmp_end
     set a, c
     set pc, pop

; strlen(char* a)
:strlen
     set b, a

:strlen_loop
     ife [a], 0
          set pc, strlen_end

     add a, 1
     set pc, strlen_loop

:strlen_end
     sub a, b
     set pc, pop


; memfill(memory, length, value)
:memfill
    ife b, 0
         set pc, pop

    :memfill_loop
    set [a], c
    add a, 1
    sub b, 1
    ifn b, 0
         set pc, memfill_loop

    set pc, pop

; random()
:random
     mul [entropy], 0x1451
     add [entropy], 1
     mul a, [entropy]
     set a, o
     set pc, pop

; puts(char* text, word color)
; text in a
; color in b
:puts
     set push, i
     set i, [video_cur]

:puts_loop
     ife [a], 0
          set pc, endputs

     set [0x8000+i], [a]
     bor [0x8000+i], b

     add a, 1
     add i, 1

     set pc, puts_loop

:endputs
     set [video_cur], i
     set i, pop
     set pc, pop

; print(char* a)
:print
     set b, 0x7000
     jsr puts
     set pc, pop

; newline
:newline
     set a, 0x0020
     set b, [video_cur]
     mod b, a
     sub a, b
     add [video_cur], a

     ife [video_cur], 0x8200
          set [video_cur], 0

     ifg [video_cur], 0x8200
          set [video_cur], 0

     set pc, pop


; printl(char* a)
:printl
     jsr print
     jsr newline
     set pc, pop

; putc(word char, word color)
:putc
     set c, [video_cur]
     bor a, b
     set [0x8000+c], a

     add [video_cur], 1

     set pc, pop


; flashputs(char* text, word color)
; text pointer in a
; color in first bytes of b
:flashputs
     set push, i
     set i, [video_cur]

     bor b, 0x0080 ; making text flashy
:flashputsloop
     ife [a], 0
          set pc, endflashputs


     set [0x8000+i], [a] ; displaying
     bor [0x8000+i], b  ; setting color

     add a, 1
     add i, 1
     set pc, flashputsloop

:endflashputs
     set [video_cur], i
     set i, pop
     set pc, pop

; readkey()
; waits for key and returns it in a
:readkey
     set a, [0x9000]
     ife a, 0
          set pc, readkey

     set [0x9000], 0
     xor [entropy], a
     set pc, pop

; clear()
; clears screen
:clear
     set a, 0x8000
     set b, 0x0200
     set c, 0x0000
     jsr memfill
     set [video_cur], 0
     set pc, pop

; readline(char* buffer, word mask)
; returns a number of charactes entered
; if mask equals 0xF00F, characters are not
; shown, showing "*" instead
:readline
     set push, x
     set push, y
     set push, i

     set x, a ; keyboard buffer
     set i, 0 ; how many characters entered
     set y, [video_cur]

:readline_loop
     set [0x8000+y], 0xF0DF ; showing cursor

     jsr readkey

     set c, a ; key

     ife c, 10 ; if enter, end
          set pc, readline_end

     ife c, 8 ; if backspace
          set pc, readline_backspace

     ifg 0x0020, c ; if less than 0x20 (space)
          set pc, readline_loop

     ifg c, 0x007E ; if more than ~
          set pc, readline_loop

     add x, i
     set [x], c ; putting data into buffer
     sub x, i
     add i, 1 ; char count increased

     bor c, 0x7000
     set [0x8000+y], c

     ; if masking is enabled
     ife b, 0xF00F
          set [0x8000+y], 0x702A ; mask password character

     add y, 1
     set pc, readline_loop

:readline_end
     set [video_cur], y      ; moving cursor
     set [0x8000+y], 0x0000 ; removing cursor itself


     set a, i
     add x, i
     set [x], 0 ; terminating string
     sub x, i

     set i, pop
     set y, pop
     set x, pop
     set pc, pop


:readline_backspace
     ife i, 0
          set pc, readline_loop

     set [0x8000+y], 0x0000 ; do not show cursor
     sub i, 1 ; one character is removed
     sub y, 1 ; one character is not displayed

     set pc, readline_loop

; void locate(int row, int column)
:locate
     shl a, 5
     add a, b
     set [video_cur], a
     set pc, pop

; exit()
:exit
     set a, 7
     set b, 9
     jsr locate

     set a, msg_halted
     set b, 0xE000
     jsr puts

     set pc, halt

:msg_halted dat "SYSTEM HALTED", 0

; halt()
:halt
     set pc, halt

:excodes dat msg_panic, msg_ex_noinit

:msg_ex_noinit dat "No init!", 0
:msg_panic dat "Ooops. ", 0

; void exception(word excode)
:exception
     set push, a

     set a, 0
     set b, 0
     jsr locate

     set a, msg_panic
     set b, 0xF000
     jsr puts

     set a, pop

     ife a, 0      ; if no additional error code
          jsr exit

     set b, 0xC000
     jsr puts

     jsr exit


; void substr(char* source, word start, word length)
; returns pointer to a buffer
:substr
     set push, i
     set push, z
     set i, b
     add i, c ; calculate last address

     add a, b ; starting from start
     set b, buffer  ; using global buffer!
     set z, b
     jsr memcpy

     add b, i
     set [b], 0

     set a, z ; returning
     set z, pop
     set i, pop
     set pc, pop


; void memcpy(void* source, void* dest, length)
; from the AtlasOS project
:memcpy
     set push, a
     set push, b
     set push, c

     ; Calulate the last address
     add c, a

:memcpy_loop
     set [b], [a]
     add a, 1
     add b, 1
     ifn a, c
          set pc, memcpy_loop

     set c, pop
     set b, pop
     set a, pop
     set pc, pop


; ##############################################################################
;
; main body


:mcp_init
     jsr clear
     ifn [module_entry], 0
          jsr [module_entry]

     set a, msg_ex_noinit
     jsr exception
:mcp_end


